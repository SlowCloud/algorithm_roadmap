## 선행
- 시간복잡도
- 우선순위 큐
- ~~고등수학 지식(?)~~

## 연관
- 프림 알고리즘
- 벨만-포드 알고리즘

# 다익스트라(Dijkstra)

> 가중치가 있는 그래프에서, 한 정점에서부터 다른 정점들까지의 최단거리를 $O(ElogV)$ 안에 찾는 알고리즘

알고리즘 수업을 들어보았다면 한번쯤은 들어보았을 최단거리 탐색 알고리즘이다.

시작 정점을 탐색 정점 그룹 $S$에 들어 있다고 생각해본다. 이 때, 모든 정점이 $S$에 포함될 때까지 아래의 알고리즘을 수행한다.

- $S$ 내 점과 가장 가까운 $S$ 외부의 점을 하나 구한다.
- 해당 점을 $S$에 포함시킨다.

정점의 개수를 $V$, 간선의 개수를 $E$라고 가정한다. $S$ 외부의 점을 검사하므로, 최대 $V$개의 점을 검사하게 되고, $S$ 내 점의 개수가 $V$개가 될 때까지 진행하므로 시간복잡도는 $O(V^2)$가 된다.

### 우선순위 큐를 이용한 최적화

우선순위 큐를 쓰면 시간복잡도를 $O(ElogV)$로 최적화할 수 있다.

작은 값을 우선하는 우선순위 큐를 사용한다. 우선순위 큐에는 $S$와 연결된 간선이 들어가게 된다. 알고리즘을 간략히 설명하자면 아래와 같다.

- $S$에 새로 추가된 정점과 연결된 모든 정점들까지의 거리를 우선순위 큐에 넣는다.
- 우선순위 큐에서 가장 가까운 거리를 하나 꺼낸다.
- 새 정점을 $S$에 추가한다.

모든 간선을 우선순위 큐에 넣었다 빼는 작업을 수행하므로, 시간복잡도는 $O(ElogE)$이다.

일반적인 그래프의 경우 $E \lt V^2$이므로 $O(logE) = O(logV)$이고, 즉 최종 시간복잡도가 $O(ElogV)$가 된다... 라고 하는데, 왜 굳이 저렇게 하는지는 잘 모르겠다.

$O(logE) = O(logV)$를 설명하자면, $E < V^2$이면 $logE < log V^2$이고, $logV^2 = 2logV$이므로 $O(logE) = O(logV)$가 된다.

### 이모저모

최단경로 하면 가장 먼저 떠올리는 알고리즘이고, 자주 쓰이는 알고리즘이므로 기억해두는 것이 좋다.

## 코드

> C++

일반적으로 거리만 구하는 경우라면 아래의 코드를 사용한다.

```

// 빠른 코드 작성을 위해 간결한 타입으로 만든다.
typedef pair<int, int> ii;

// int의 최대 크기는 21억이다.
constexpr int INF = 2e9;

// 간선을 담은 자료구조, 즉 그래프이다. 구조는 아래와 같다.
// G = {{{w, j}, ...}, ...}
// G[i] = {{w, j}, ...}
// i번째 정점에서 j로 가는, 가중치 w의 간선들을 담고 있는 형태이다.
// 가중치가 먼저 오는 이유는, 우선순위 큐에서 가중치를 중심으로 정렬하기 위함이다.
vector<vector<ii>> G;

// G의 s 정점에서부터 다른 정점들까지의 거리를 반환한다.
vector<int> dijkstra(int s, vector<vector<ii>> G) {

    vector<int> d(G.size(), INF);
    d[s] = 0;

    // 작은 값을 우선하는 우선순위 큐
    priority_queue<ii, vector<ii>, greater<>> pq;
    pq.push({0, s});

    // 우선순위 큐가 빌 때까지(더 이상 갱신할 거리가 없어질 때까지)
    while(pq.size()) {

        // 현재 거리/정점을 구한다.
        auto now = pq.top();
        pq.pop();

        // 현재 정점과 연결된 다음 정점들에 대해
        for(ii next : G[now.second]) {

            // 현재 정점까지의 거리 + 간선 가중치가 더 작다면
            if(d[next.second] > now.first + next.first) {

                // 거리를 갱신하고 우선순위 큐에 넣는다.
                d[next.second] = now.first + next.first;
                pq.push({d[next.second], next.second});

            }

        } // for next : G[now.second]

    } // while pq.size()

    // 거리를 반환한다.
    return d;
}

```

## 연습 문제

### 초급

- [최단경로[G4]](https://www.acmicpc.net/problem/1753)
- [녹색 옷 입은 애가 젤다지?[G4]](https://www.acmicpc.net/problem/4485)
- [특정한 최단 경로[G4]](https://www.acmicpc.net/problem/1504)


**코딩테스트를 준비하시는 분들은 여기까지만 보시면 됩니다.**
<hr>

### 중급
- [주유소[P5]](https://www.acmicpc.net/problem/13308)