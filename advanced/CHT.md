## 선행

## 연관
- 슬로프 트릭

# Convex Hull Trick

> $O(N^2)$이 걸리는 DP 계산을 $O(NlogN)$으로 최적화해 봅시다.

이름에는 볼록 껍질이 들어가 있지만 실제로 사용하지는 않고, 함수 그래프의 모양이 볼록 껍질처럼 보여서 이렇게 부른다. 수학계에서 실제로 부르는 이름이 따로 있다고는 한다.

DP 식이 아래와 같이 바뀔 수 있을 때 적용할 수 있다.

> $dp[j] = min_{i \lt j} ( dp[i] + A[j] \times B[j] + C[i] ) + D[j]$  
> $j \lt i, B[j] > B[i]$

또는

> $dp[j] = max_{i \lt j} ( dp[i] + A[j] \times B[j] + C[i] ) + D[j]$  
> $j \lt i, B[j] < B[i]$

이 때, B는 monge array이어야 한다.

### 최적화 원리

증명은 [koosaga님의 블로그](https://koosaga.com/242)에서.

### 예시 문제 풀이

#### 나무 자르기[P2]

문제를 간략히 하면, 가장 빨리 마지막 나무를 벨 수 있는 시간을 구하는 것이다. 마지막 나무를 자르면, 남은 나무들은 충전 시간 없이 모조리 자를 수 있다.

가장 먼저 떠오르는 계산식은 아래와 같을 것이다.
> $DP[i] = min_{j  \lt i} (B[j] \times A[i] + DP[j])$

여기서 DP[i]는 i번째 나무까지 잘랐을 때의 최소 비용이고, B[j]는 j번째 나무를 베었을 때의 충전 시간, A[i]는 i번째 나무의 높이를 가리킨다.

코드로 작성하면 아래처럼 된다.

```

int f(int i) {
    int& now = dp[i];
    for(int j = 0; j < i; j++) {
        now = min(now, B[j] * A[i] + f(j));
    }
    return now;
}

```

위 식대로 계산하면 시간복잡도는 $O(N^2)$이다. $N = 100'000$이므로 시간 내로 문제를 해결하지 못한다. 계산량을 줄이는 방법은 없을까?

위 식에서는 min 값을 가지지 못하는 불필요한 연산이 존재한다. 이는 CHT를 이용해서 줄일 수 있게 된다. 함수 그래프를 나타냈을 때, 어떤 A[i]에서도 최솟값에 해당하지 않는 간선들을 제거해서 연산을 줄이는 것이다.

첫 나무는 충전 시간을 들이지 않고 자르므로, 기울기가 B[i]인 간선 하나를 넣으면 된다. 그리고 DP[1] = 0이 된다.

```
ch.insert({B[1], 0})
```

두 번째 나무부터는 충전 시간을 계산해야 한다. 두 번째 나무를 자르는 비용은 B[i - 1] * A[i] + DP[i - 1], 즉 B[1] * A[2] + DP[1]이다.

이제 위 식을 따라서 반복문을 통해 Line을 저장하고, DP 값을 찾아서 저장하는 식으로 계산하면 된다.

### 이모저모

연산을 쉽게 하기 위해, LineContainer라는 객체를 만들어 Wx+b 식을 관리하는 방법이 있다.

Li-Chao Tree라는 자료구조를 사용해서 간선을 관리할 수도 있다. 해당 자료구조를 공부하려면 동적 세그먼트 트리를 공부해야 한다.

## 연습 문제

- 연습 문제
    - [나무 자르기[P2]](https://www.acmicpc.net/problem/13263)
        - CHT 연습 문제
    - [특공대[D5]](https://www.acmicpc.net/problem/4008)
        - CHT가 가능한 식으로 변환하는 연습 문제

- 활용 문제
    - [땅따먹기[D5]](https://www.acmicpc.net/problem/6171)
        - CHT와 전처리가 필요한 문제
    - [수열 나누기[D4]](https://www.acmicpc.net/problem/10067)
        - 간선의 개수를 제한한다면? 어떤 간선이 사용되었는지 확인하려면?