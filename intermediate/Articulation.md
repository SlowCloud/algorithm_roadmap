## 선행

- DFS

## 연관

- 강한 연결 요소

# 단절점과 단절선

> 없어졌을 때, 그래프를 2개로 나눌 수 있는 점/간선을 구해봅시다.

DFS로 그래프의 정점들에 새로운 번호를 부여하면서, 해당 번호들을 통해 단절점/단절선을 확인할 수 있다.

우선 단절점을 구하는 방법보다 알아본다. 단절점을 구할 수 있으면, 단절선도 구할 수 있다.

DFS 재귀 함수를 작성할 때, 방문하는 정점들마다 새로운 번호를 부여하고, 해당 정점에서 방문할 수 있는 정점들 중 가장 작은 번호를 반환하는 함수를 만든다.


그리고 반환받은 정점의 번호가 자신보다 크거나 같다면, 현재 점이 단절점이다.

## 구현

> C++
## 단절점

잘못 구현된 코드입니다! 참고용으로만 확인해주세요.

```
// 정점에 부여할 번호를 기억한다.
int number = 1;

// 정점의 번호를 기억할 배열이다.
// 정점 개수만큼 크기를 설정한다.
int d[V];

// x에서부터 방문할 수 있는 정점들 중 가장 작은 번호를 반환한다.
int dfs(int x) {
    
    // 새 번호를 부여한다.
    d[x] = number++;

    // 반환값을 기록한다.
    int ret = d[x];

    // 다음 정점들에 대해 DFS를 진행한다.
    for(int next : G[x]) {
        if(d[next] == 0) ret = min(ret, dfs(next));

        // 이미 방문한 점이라면, 번호만 검사한다.
        else ret = min(ret, d[next]);
    }

    // 정점 번호가 현재 번호보다 크다면, 자신 이전의 정점들에 닿지 못한 것이므로 단절점이다.
    if(ret >= d[x]) {
        // 단절점을 기록하던지 하면 된다.
        /* ... */
    }

    return ret;
}
```

## 연습 문제
- [단절점[P4]](https://www.acmicpc.net/problem/11266)
- [단절선[P4]](https://www.acmicpc.net/problem/11400)
